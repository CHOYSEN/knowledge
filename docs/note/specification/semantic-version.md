## 语义版本控制(Semantic Versioning 2.0)

#### 基本介绍

语义化版本由三部分组成：`major.minor.patch`。

* `major`：主版本号，当你的包拥有不兼容的API变更时需要增加该版本号的值。
* `minor`：次版本号，当你以向后兼容的方式为你的包增加功能时需要增加该版本号。
* `patch`：补丁版本号，当你的包拥有向后兼容的bug修复时需要增加该版本号。

实际上你可以在 `major.minor.patch` 格式上进行扩展，添加预发布版本(`pre-release version`)和版本的构建元数据(`build metadata`)。

语义版本控制的好处是，如果一个包的版本号变更完全依照语义版本控制的规定，那么使用者将很容易的从版本号的变更中得知此包底层代码的变更，这对于包的使用者来说意义重大。同时一个依照语义版本控制的包也将会被包的发现者认为是更加“靠谱的”。

#### 语义版本空的规范

请注意下文中出现的关键词，如：**必须**、**不能/不得**、**需要**、**可以** 等。实际上这些关键词也是有规范来定义的，具体查看：[https://tools.ietf.org/html/rfc2119](https://tools.ietf.org/html/rfc2119)

* 1、使用语义版本的项目**必须**要有对该项目公共API清晰且全面的介绍。
* 2、普通的版本号格式**必须**符合 `major.minor.patch` 的格式，且 `major`、`minor` 和 `patch` 都是非负整数(即正整数或0)，并且**不能**包含前导0。每个版本号元素都**必须**以数字递增的方式增加，例如：`1.9.0` -> `1.10.0` -> `1.11.0`
* 3、一个包发布了某个版本之后，该版本的内容将**不得**修改。任何修改**必须**作为新版本再次发布。
* 4、如果你要发布一个初始开发的包(即正在开发中或未经测试的包)，那么该包的主版本号**需要**为 `0`，例如 `0.1.2`。这意味着该包的API还不稳定，随时可能发生变化。
* 5、`1.0` 版本包意味着该包定义了稳定的公共的API，该包版本号后续的变更取决于该包的更改方式和API的变更。
* 6、如果你只是引入了向后兼容的bug修复，则**必须**增加补丁版本号(`patch`)。
* 7、如果新的且向后兼容的功能被添加到公共API，则**必须**增加次版本号(`minor`)，同样的如果把现有API标记为被反对的，也**必须**增加次版本号(`minor`)。如果你的包添加一些实质性的新功能或者改善，你也**可以**增加次版本号(`minor`)。最后要注意的是，如果次版本号(`minor`)增加了，那么**必须**要将补丁版本号(`patch`)重置为0。
* 8、如果有新的且不向后兼容的功能被添加到了API，那么主版本号(`major`)**必须**增加。注意，如果主版本号(`major`)增加了，那么**必须**要将次版本号(`minor`)以及补丁版本号(`patch`)全部重置为0。
* 9、**可以**在补丁版本号(`patch`)之后使用连字符(`-`)和一些列的点分隔符(`.`)来标识预发布版本号(`pre-release version`)。标识符**必须**只能由字母、数字或者连字符(`-`)组成，且不能为空，数字类型的标识符**不能**有前导0。预发布版本号(`pre-release version`)的优先级低于其关联的普通版本。一个预发布版本号(`pre-release version`)代表着该版本是不稳定的，并且该版本可能不满足其关联的普通版本的兼容性要求。一些预发布版本号的例子：`1.0.0-alpha`、`1.0.0-alpha.1`、`1.0.0-0.3.7`、`1.0.0-x.7.z.92`。
* 10、**可以**在补丁版本号(`patch`)或预发布版本号(`pre-release version`)之后使用加号(`+`)以及一系列的点分隔符(`.`)为该版本添加构建元数据(`build metadata`)，构建元数据的标识符**必须**只能由字母、数字、连字符组成且不能为空。构建元数据不参与版本号优先级的比较，这意味着只有构建元数据不同的两个版本具有相同的优先级。例如这几个版本具有相同的优先级：`1.0.0-alpha+001`、`1.0.0+20130313144700`、`1.0.0-beta+exp.sha.5114f85`。
* 11、优先级定义了在版本号排序的过程中版本号是如何互相比较的，**必须**通过将版本号按顺序分为 `major`、`minor`、`patch` 和 `pre-release` 并一次对比他们的标识符来计算优先级。当从左到右比较这些标识符中的每一个时，优先级由第一个差异确定，规则如下：
  * `major`、`minor` 和 `patch` 版本的大小总是通过比较数字大小来决定的，例如：`1.0.0` < `2.0.0` < `2.1.0` < `2.1.1`。
  * 当 `major`、`minor` 和 `patch` 版本相同时，带有 `pre-release version` 的版本的优先级始终小于普通版本。例如：`1.0.0-alpha` < `1.0.0`。
  * 比较两个预发布版本的规则与对比 `major`、`minor` 和 `patch` 版本类似，将预发布版本按点分隔符分开，从左到右依次对比这些标识符，且优先级由第一个差异确定，规则如下：
    * 只包含数字的标识符通过比较数字的大小确定优先级，包含字符和中横线的标识符则通过比较字符在 ASCII 码中的顺序来比较优先级。
    * 数字标识符的优先级低于非数字标识符。
    * 通过点分隔符将预发布版本号分割之后，拥有更多的标识符的版本也将拥有更高的优先级。
    * 如果全部都相等，则两个版本优先级相同。

下面是一个完整的例子：

`1.0.0-alpha` < `1.0.0-alpha.1` < `1.0.0-alpha.beta` < `1.0.0-beta` < `1.0.0-beta.2` < `1.0.0-beta.11` < `1.0.0-rc.1` < `1.0.0`

#### 一些建议

以上内容来自：[https://semver.org/#semantic-versioning-200](https://semver.org/#semantic-versioning-200)。如果你正在创建一个包并准备发布它，那么请你遵守这套规则。你可以在你将此链接添加到你的 README 中，这样当别人看到你的包时即可明确的知道你的包时遵守语义版本控制的，这样使用者会对你的包好感倍增，因为使用者会认为遵守语义版本控制的包将更加靠谱，同时也显得更加专业。